From 85dce8742a6d1f11e776262a0023f00faa358ad4 Mon Sep 17 00:00:00 2001
From: Jon Rubens <jonathanrubens@gmail.com>
Date: Wed, 24 Jan 2024 19:45:55 -0800
Subject: [PATCH] Enable frame parameter alpha_background for MacOS

---
 src/macfont.m |  10 ++-
 src/nsfns.m   |  42 +++++++++---
 src/nsterm.m  | 184 +++++++++++++++++++++++++++++---------------------
 3 files changed, 150 insertions(+), 86 deletions(-)

diff --git a/src/macfont.m b/src/macfont.m
index 4ff720c5dd2..a6e99e09e12 100644
--- a/src/macfont.m
+++ b/src/macfont.m
@@ -2994,9 +2994,14 @@ So we use CTFontDescriptorCreateMatchingFontDescriptor (no
             CG_SET_FILL_COLOR_WITH_FACE_FOREGROUND (context, face);
           else
             CG_SET_FILL_COLOR_WITH_FRAME_CURSOR (context, f);
-        }
+	  CGContextSetAlpha(context, 1);
+	}
       else
-        CG_SET_FILL_COLOR_WITH_FACE_BACKGROUND (context, face);
+	{
+	  CGContextSetAlpha(context, f->alpha_background);
+	  CG_SET_FILL_COLOR_WITH_FACE_BACKGROUND (context, face);
+	}
+      CGContextClearRect(context, background_rect);
       CGContextFillRects (context, &background_rect, 1);
     }
 
@@ -3005,6 +3010,7 @@ So we use CTFontDescriptorCreateMatchingFontDescriptor (no
       CGAffineTransform atfm;
 
       CGContextScaleCTM (context, 1, -1);
+      CGContextSetAlpha(context, 1);
       if (s->hl == DRAW_CURSOR)
         {
           if (face && (NS_FACE_BACKGROUND (face)
diff --git a/src/nsfns.m b/src/nsfns.m
index a2c50468cd1..64a484c91a9 100644
--- a/src/nsfns.m
+++ b/src/nsfns.m
@@ -299,7 +299,7 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
   struct face *face;
   NSColor *col;
   NSView *view = FRAME_NS_VIEW (f);
-  EmacsCGFloat alpha;
+  EmacsCGFloat alpha = f->alpha_background;
 
   block_input ();
   if (ns_lisp_to_color (arg, &col))
@@ -314,11 +314,10 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
   f->output_data.ns->background_color = col;
 
   FRAME_BACKGROUND_PIXEL (f) = [col unsignedLong];
-  alpha = [col alphaComponent];
 
   if (view != nil)
     {
-      [[view window] setBackgroundColor: col];
+      [[view window] setBackgroundColor: [col colorWithAlphaComponent: alpha]];
 
       if (alpha != (EmacsCGFloat) 1.0)
           [[view window] setOpaque: NO];
@@ -328,10 +327,7 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
       face = FRAME_DEFAULT_FACE (f);
       if (face)
         {
-          col = [NSColor colorWithUnsignedLong:NS_FACE_BACKGROUND (face)];
-          face->background = [[col colorWithAlphaComponent: alpha]
-                               unsignedLong];
-
+          face->background = [col unsignedLong];
           update_face_from_frame_parameter (f, Qbackground_color, arg);
         }
 
@@ -344,6 +340,36 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
   unblock_input ();
 }
 
+static void
+ns_set_alpha_background (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+{
+  NSView *view = FRAME_NS_VIEW (f);
+  double alpha = 1.0;
+
+  if (NILP (arg))
+    alpha = 1.0;
+  else if (FLOATP (arg))
+    {
+      alpha = XFLOAT_DATA (arg);
+      if (! (0 <= alpha && alpha <= 1.0))
+	args_out_of_range (make_float (0.0), make_float (1.0));
+    }
+  else if (FIXNUMP (arg))
+    {
+      EMACS_INT ialpha = XFIXNUM (arg);
+      if (! (0 <= ialpha && ialpha <= 100))
+	args_out_of_range (make_fixnum (0), make_fixnum (100));
+      alpha = ialpha / 100.0;
+    }
+  else
+    wrong_type_argument (Qnumberp, arg);
+
+  f->alpha_background = alpha;
+  [[view window] setBackgroundColor: [f->output_data.ns->background_color
+					 colorWithAlphaComponent: alpha]];
+  recompute_basic_faces (f);
+  SET_FRAME_GARBAGED (f);
+}
 
 static void
 ns_set_cursor_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
@@ -1109,7 +1135,7 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
   ns_set_z_group,
   0, /* x_set_override_redirect */
   gui_set_no_special_glyphs,
-  gui_set_alpha_background,
+  ns_set_alpha_background,
   NULL,
 #ifdef NS_IMPL_COCOA
   ns_set_appearance,
diff --git a/src/nsterm.m b/src/nsterm.m
index a4398e79211..12138bbca6b 100644
--- a/src/nsterm.m
+++ b/src/nsterm.m
@@ -2617,8 +2617,9 @@ Hide the window (X11 semantics)
 
   block_input ();
   ns_focus (f, &r, 1);
-  [[NSColor colorWithUnsignedLong:NS_FACE_BACKGROUND
-			    (FACE_FROM_ID (f, DEFAULT_FACE_ID))] set];
+  [[[NSColor colorWithUnsignedLong:NS_FACE_BACKGROUND
+				 (FACE_FROM_ID (f, DEFAULT_FACE_ID))]
+                                 colorWithAlphaComponent: f->alpha_background] set];
   NSRectFill (r);
   ns_unfocus (f);
 
@@ -2646,7 +2647,7 @@ Hide the window (X11 semantics)
 
   r = NSIntersectionRect (r, [view frame]);
   ns_focus (f, &r, 1);
-  [[NSColor colorWithUnsignedLong:NS_FACE_BACKGROUND (face)] set];
+  [[[NSColor colorWithUnsignedLong:NS_FACE_BACKGROUND (face)] colorWithAlphaComponent: f->alpha_background] set];
 
   NSRectFill (r);
 
@@ -2750,7 +2751,7 @@ Hide the window (X11 semantics)
         return;
 
       ns_focus (f, NULL, 1);
-      [[NSColor colorWithUnsignedLong:NS_FACE_BACKGROUND (face)] set];
+      [[[NSColor colorWithUnsignedLong:NS_FACE_BACKGROUND (face)] colorWithAlphaComponent: f->alpha_background] set];
       NSRectFill (NSMakeRect (0, margin, width, border));
       NSRectFill (NSMakeRect (0, 0, border, height));
       NSRectFill (NSMakeRect (0, margin, width, border));
@@ -2802,7 +2803,7 @@ Hide the window (X11 semantics)
           NSRect r = NSMakeRect (0, y, FRAME_PIXEL_WIDTH (f), height);
           ns_focus (f, &r, 1);
 
-          [[NSColor colorWithUnsignedLong:NS_FACE_BACKGROUND (face)] set];
+          [[[NSColor colorWithUnsignedLong:NS_FACE_BACKGROUND (face)] colorWithAlphaComponent: f->alpha_background] set];
           NSRectFill (NSMakeRect (0, y, width, height));
           NSRectFill (NSMakeRect (FRAME_PIXEL_WIDTH (f) - width,
                                   y, width, height));
@@ -2955,23 +2956,28 @@ Hide the window (X11 semantics)
   if (!p->overlay_p)
     {
       /* Work out the rectangle we will need to clear.  */
-      clearRect = NSMakeRect (p->x, p->y, p->wd, p->h);
+      clearRect = NSMakeRect(p->x, p->y, p->wd, p->h);
 
       if (p->bx >= 0)
-        clearRect = NSUnionRect (clearRect, NSMakeRect (p->bx, p->by, p->nx, p->ny));
+        clearRect = NSUnionRect(clearRect,
+                                NSMakeRect(p->bx, p->by, p->nx, p->ny));
 
       /* Handle partially visible rows.  */
-      clearRect = NSIntersectionRect (clearRect, rowRect);
+      clearRect = NSIntersectionRect(clearRect, rowRect);
 
       /* The visible portion of imageRect will always be contained
-	 within clearRect.  */
-      ns_focus (f, &clearRect, 1);
-      if (!NSIsEmptyRect (clearRect))
+        within clearRect.  */
+      ns_focus(f, &clearRect, 1);
+
+      if (!NSIsEmptyRect(clearRect))
         {
-          NSTRACE_RECT ("clearRect", clearRect);
+          NSTRACE_RECT("clearRect", clearRect);
+
+          /* Combine the alpha-background logic with setting the color.  */
+          [[[NSColor colorWithUnsignedLong:face->background]
+              colorWithAlphaComponent:f->alpha_background] set];
 
-          [[NSColor colorWithUnsignedLong:face->background] set];
-          NSRectFill (clearRect);
+          NSRectFill(clearRect);
         }
     }
 
@@ -3002,7 +3008,7 @@ Hide the window (X11 semantics)
       else
         bm_color = f->output_data.ns->cursor_color;
 
-      [bm_color set];
+      [[bm_color colorWithAlphaComponent:f->alpha_background] set];
       [bmp fill];
 
       [bmp release];
@@ -3736,68 +3742,70 @@ larger if there are taller display elements (e.g., characters
 static void
 ns_dumpglyphs_box_or_relief (struct glyph_string *s)
 /* --------------------------------------------------------------------------
-      Function modeled after x_draw_glyph_string_box ().
-      Sets up parameters for drawing.
+   Modeled after x_draw_glyph_string_background, which draws BG in
+   certain cases.  Others are left to the text rendering routine.
    -------------------------------------------------------------------------- */
 {
-  int right_x, last_x;
-  char left_p, right_p;
-  struct glyph *last_glyph;
-  NSRect r;
-  int hthickness, vthickness;
   struct face *face = s->face;
+  NSRect r;
 
-  vthickness = face->box_vertical_line_width;
-  hthickness = face->box_horizontal_line_width;
-
-  NSTRACE ("ns_dumpglyphs_box_or_relief");
+  NSTRACE ("ns_maybe_dumpglyphs_background");
 
-  last_x = ((s->row->full_width_p && !s->w->pseudo_window_p)
-	    ? WINDOW_RIGHT_EDGE_X (s->w)
-	    : window_box_right (s->w, s->area));
-  if (s->cmp || s->img)
-    last_glyph = s->first_glyph;
-  else if (s->first_glyph->type == COMPOSITE_GLYPH
-	   && s->first_glyph->u.cmp.automatic)
+  if (!s->background_filled_p)
     {
-        struct glyph *end = s->row->glyphs[s->area] + s->row->used[s->area];
-	struct glyph *g = s->first_glyph;
-	for (last_glyph = g++;
-	     g < end && g->u.cmp.automatic && g->u.cmp.id == s->cmp_id
-	       && g->slice.cmp.to < s->cmp_to;
-	     last_glyph = g++)
-	  ;
-    }
-  else
-    last_glyph = s->first_glyph + s->nchars - 1;
-
-  right_x = ((s->row->full_width_p && s->extends_to_end_of_line_p
-	      ? last_x - 1 : min (last_x, s->x + s->background_width) - 1));
-
-  left_p = (s->first_glyph->left_box_line_p
-	    || (s->hl == DRAW_MOUSE_FACE
-		&& (s->prev == NULL || s->prev->hl != s->hl)));
-  right_p = (last_glyph->right_box_line_p
-	     || (s->hl == DRAW_MOUSE_FACE
-		 && (s->next == NULL || s->next->hl != s->hl)));
+      int box_line_width = max (s->face->box_horizontal_line_width, 0);
 
-  r = NSMakeRect (s->x, s->y, right_x - s->x + 1, s->height);
+      /* HEAD logic: if stippled, set the stipple mask and jump to fill.  */
+      if (s->stippled_p)
+        {
+          struct ns_display_info *dpyinfo = FRAME_DISPLAY_INFO (s->f);
+          [[dpyinfo->bitmaps[face->stipple-1].img stippleMask] set];
+          goto fill;
+        }
+      /* HEAD logic: various checks that determine whether to clear the BG. */
+      else if (FONT_HEIGHT(s->font) < s->height - 2 * box_line_width
+               /* … or other HEAD conditions … */
+               || s->font_not_found_p
+               || s->extends_to_end_of_line_p
+               || force_p)
+        {
+          /* CHERRY-PICK logic (with alpha background) merged into HEAD’s
+             existing background-setting code. */
+          if (s->hl != DRAW_CURSOR)
+            {
+              if (NS_FACE_BACKGROUND(face) != 0)
+                {
+                  /* Use alpha_background here. */
+                  [[[NSColor colorWithUnsignedLong:NS_FACE_BACKGROUND(face)]
+                     colorWithAlphaComponent:s->f->alpha_background] set];
+                }
+              else
+                {
+                  /* Fallback frame background color (unchanged HEAD logic). */
+                  [FRAME_BACKGROUND_COLOR(s->f) set];
+                }
+            }
+          else if (face && (NS_FACE_BACKGROUND(face)
+                            == [(NSColor *) FRAME_CURSOR_COLOR(s->f) unsignedLong]))
+            {
+              [[NSColor colorWithUnsignedLong:NS_FACE_FOREGROUND(face)] set];
+            }
+          else
+            {
+              [FRAME_CURSOR_COLOR(s->f) set];
+            }
 
-  /* TODO: Sometimes box_color is 0 and this seems wrong; should investigate.  */
-  if (s->face->box == FACE_SIMPLE_BOX && s->face->box_color)
-    {
-      ns_draw_box (r, abs (hthickness), abs (vthickness),
-                   [NSColor colorWithUnsignedLong:face->box_color],
-                   left_p, right_p);
-    }
-  else
-    {
-      ns_draw_relief (r, abs (hthickness), abs (vthickness),
-                      s->face->box == FACE_RAISED_BOX,
-                      1, 1, left_p, right_p, s);
+        fill:
+          r = NSMakeRect(s->x, s->y + box_line_width,
+                         s->background_width,
+                         s->height - 2 * box_line_width);
+          NSRectFill(r);
+          s->background_filled_p = 1;
+        }
     }
 }
 
+
 static void
 ns_maybe_dumpglyphs_background (struct glyph_string *s, char force_p)
 /* --------------------------------------------------------------------------
@@ -3816,6 +3824,7 @@ Function modeled after x_draw_glyph_string_box ().
 
       if (s->stippled_p)
 	{
+<<<<<<< HEAD
 	  struct ns_display_info *dpyinfo = FRAME_DISPLAY_INFO (s->f);
 	  [[dpyinfo->bitmaps[face->stipple-1].img stippleMask] set];
 	  goto fill;
@@ -3840,6 +3849,29 @@ Function modeled after x_draw_glyph_string_box ().
 	    [[NSColor colorWithUnsignedLong:NS_FACE_FOREGROUND (face)] set];
 	  else
 	    [FRAME_CURSOR_COLOR (s->f) set];
+=======
+          struct face *face = s->face;
+          if (!face->stipple)
+            {
+              if (s->hl != DRAW_CURSOR)
+                [(NS_FACE_BACKGROUND (face) != 0
+		  ? [[NSColor colorWithUnsignedLong:NS_FACE_BACKGROUND (face)]
+		      colorWithAlphaComponent: s->f->alpha_background]
+                  : FRAME_BACKGROUND_COLOR (s->f)) set];
+
+              else if (face && (NS_FACE_BACKGROUND (face)
+                                == [(NSColor *) FRAME_CURSOR_COLOR (s->f)
+                                                unsignedLong]))
+                [[NSColor colorWithUnsignedLong:NS_FACE_FOREGROUND (face)] set];
+              else
+                [FRAME_CURSOR_COLOR (s->f) set];
+            }
+          else
+            {
+              struct ns_display_info *dpyinfo = FRAME_DISPLAY_INFO (s->f);
+              [[dpyinfo->bitmaps[face->stipple-1].img stippleMask] set];
+            }
+>>>>>>> 9b436ccb00e (Enable frame parameter alpha_background for MacOS)
 
 	fill:
 	  r = NSMakeRect (s->x, s->y + box_line_width,
@@ -3971,7 +4003,7 @@ Function modeled after x_draw_glyph_string_box ().
      otherwise, since we composite the image under NS (instead of mucking
      with its background color), we must clear just the image area.  */
 
-  [[NSColor colorWithUnsignedLong:NS_FACE_BACKGROUND (face)] set];
+  [[[NSColor colorWithUnsignedLong:NS_FACE_BACKGROUND (face)] colorWithAlphaComponent: s->f->alpha_background] set];
 
   if (bg_height > s->slice.height || s->img->hmargin || s->img->vmargin
       || s->img->mask || s->img->pixmap == 0 || s->width != s->background_width)
@@ -4041,7 +4073,7 @@ Function modeled after x_draw_glyph_string_box ().
   if (s->hl == DRAW_CURSOR)
     {
       [FRAME_CURSOR_COLOR (s->f) set];
-      tdCol = [NSColor colorWithUnsignedLong: NS_FACE_BACKGROUND (face)];
+      tdCol = [[NSColor colorWithUnsignedLong: NS_FACE_BACKGROUND (face)] colorWithAlphaComponent: s->f->alpha_background];
     }
   else
     tdCol = [NSColor colorWithUnsignedLong: NS_FACE_FOREGROUND (face)];
@@ -4134,10 +4166,10 @@ Function modeled after x_draw_glyph_string_box ().
 		face = FACE_FROM_ID (s->f, MOUSE_FACE_ID);
 	      prepare_face_for_display (s->f, face);
 
-	      [[NSColor colorWithUnsignedLong: face->background] set];
+	      [[[NSColor colorWithUnsignedLong: face->background] colorWithAlphaComponent: s->f->alpha_background] set];
 	    }
 	  else
-	    [[NSColor colorWithUnsignedLong: s->face->background] set];
+	    [[[NSColor colorWithUnsignedLong: s->face->background] colorWithAlphaComponent: s->f->alpha_background] set];
 	  NSRectFill (NSMakeRect (x, y, w, h));
 	}
     }
@@ -4168,7 +4200,7 @@ Function modeled after x_draw_glyph_string_box ().
 	  else if (s->stippled_p)
 	    [[dpyinfo->bitmaps[s->face->stipple - 1].img stippleMask] set];
 	  else
-	    [[NSColor colorWithUnsignedLong: s->face->background] set];
+	    [[[NSColor colorWithUnsignedLong: s->face->background] colorWithAlphaComponent: s->f->alpha_background] set];
 
 	  NSRectFill (NSMakeRect (x, s->y, background_width, s->height));
 	}
@@ -8609,8 +8641,8 @@ - (void)toggleFullScreen: (id)sender
         }
 
       [w setContentView:[fw contentView]];
-      [w setBackgroundColor: col];
-      if ([col alphaComponent] != (EmacsCGFloat) 1.0)
+      [w setBackgroundColor: [col colorWithAlphaComponent: f->alpha_background]];
+      if (f->alpha_background != (EmacsCGFloat) 1.0)
         [w setOpaque: NO];
 
       f->border_width = [w borderWidth];
@@ -9347,9 +9379,9 @@ - (instancetype) initWithEmacsFrame: (struct frame *) f
       f->border_width = [self borderWidth];
 
       col = [NSColor colorWithUnsignedLong:NS_FACE_BACKGROUND
-                                     (FACE_FROM_ID (f, DEFAULT_FACE_ID))];
-      [self setBackgroundColor:col];
-      if ([col alphaComponent] != (EmacsCGFloat) 1.0)
+		      (FACE_FROM_ID (f, DEFAULT_FACE_ID))];
+      [self setBackgroundColor:[col colorWithAlphaComponent:f->alpha_background]];
+      if (f->alpha_background != (EmacsCGFloat) 1.0)
         [self setOpaque:NO];
 
       /* toolbar support */
-- 
2.39.5 (Apple Git-154)

